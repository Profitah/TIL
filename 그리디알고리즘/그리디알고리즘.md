📘 그리디 알고리즘(Greedy Algorithm)

## 그리디 알고리즘
매 순간 가장 좋아 보이는(최적의) 선택을 하는 방식으로 최종 해답을 구하는 알고리즘 기법입니다.  
즉, 현재 상태에서 당장 이득이 최대인 선택만을 반복해서 최적 해를 도출하려는 전략입니다.

## 동작 원리
문제를 여러 단계의 선택으로 나눈다.  
**각 단계마다 지역적으로 가장 최적인 선택(탐욕적 선택)**을 한다.  
모든 선택이 끝난 후 전체적으로도 최적해가 되었는지 확인한다.

## 핵심 조건
그리디 알고리즘이 정확한 해답을 구하려면 두 가지 조건을 만족해야 합니다  

- **Greedy Choice Property (탐욕 선택 속성)** : 매 단계의 가장 최적 선택이 전체 최적해의 일부여야 함  
- **Optimal Substructure (최적 부분 구조)** : 문제의 전체 최적해가 부분 문제의 최적해로 구성되어야 함  
→ 이 두 가지가 만족되지 않으면 그리디는 항상 정답을 보장하지 못합니다.

## 장점 / 단점
| 장점 | 단점 |
|------|------|
| 구현이 간단하고 빠름 | 항상 정답을 보장하지 않음 |
| 탐색 범위를 줄여 효율성 높음 | 최적의 해답이 아닐 수도 있음 |
| 많은 실전 문제에 적용 가능 | 동적 프로그래밍보다 덜 유연함 |
---

## 대표 문제 예시
1. **동전 거스름돈 문제**  
   가장 큰 동전부터 greedy하게 거슬러줌 (ex. 500원, 100원…)  
   단, 모든 동전 조합에서 항상 정답이 되지는 않음  
   예: `[500, 100, 50, 10]`이면 가능하지만 `[400, 100, 30]`이면 불가능할 수도 있음  

2. **활동 선택 문제**  
   끝나는 시간이 빠른 활동부터 선택해서 최대한 많은 활동을 선택  

3. **최소 회의실 문제, 인터벌 스케줄링**

4. **크루스칼(Kruskal) 알고리즘**  
   최소 신장 트리(MST)를 만들 때, 가장 가중치 작은 간선부터 선택  
---
## 💡 예제 코드 ① (거스름돈 문제 - Python)
```python
coins = [500, 100, 50, 10]
n = 1260
count = 0

for coin in coins:
    count += n // coin
    n %= coin

print(count)  # 출력: 6
```
---
## 💡 예제 코드 ② (잃어버린 괄호 - Python)
```python
expression = input().strip()

# 1. '-'를 기준으로 식을 나눕니다
parts = expression.split('-')

# 2. 첫 번째 그룹은 더합니다 (괄호 밖)
initial = sum(map(int, parts[0].split('+')))

# 3. 이후 그룹들은 모두 '+'로 나누어 합한 뒤, 빼줍니다
for part in parts[1:]:
    initial -= sum(map(int, part.split('+')))

print(initial)
```