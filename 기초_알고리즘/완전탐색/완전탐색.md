# 완전탐색(Brute Force)
- 가능한 모든 경우의 수를 **전부 탐색**하여 문제를 해결하는 알고리즘 기법
- 문제의 범위가 작고, 해결해야 할 경우의 수가 많지 않을 때 사용함.
-  가능한 해를 모두 탐색, 최적의 해 발견.

## 1. 완전탐색의 특징
- **모든 경우의 수를 고려**
- 시간이 오래 걸릴 수 있기 때문에 **문제 크기가 작을 때** 적합함.
- 문제를 해결하는 방식이 **단순**하고, 구현이 **직관적**임.
- 예를 들어, 문제에서 가능한 모든 조합을 구하거나, 모든 경우에 대해 조건을 체크하는 방식으로 사용됨.

## 2. 완전탐색의 예시
### 예시 1: 주어진 수들의 합으로 특정 값을 만드는 경우 찾기
주어진 수들의 집합에서 합이 특정 값을 만드는 조합이 있는지 찾는 문제를 완전탐색으로 풀 수 있음.                 
```python
def find_sum(nums, target):
    n = len(nums)
    
    # 모든 부분 집합을 탐색
    for i in range(1 << n):  # 2^n 개의 부분 집합이 있음
        subset_sum = 0
        for j in range(n):
            if i & (1 << j):  # j번째 원소를 포함하는지 확인
                subset_sum += nums[j]
        if subset_sum == target:
            return True  # 목표 값을 찾으면 True 반환
    return False  # 없으면 False 반환

# 예시
nums = [1, 2, 3, 4]
target = 5
print(find_sum(nums, target))  # 출력: True
```
### 예시 2: 모든 조합을 구하는 문제
숫자 1부터 N까지 중에서 M개를 고르는 문제의 모든 경우를 찾는 예시
```python
def combinations(nums, M):
    def dfs(start, path): 
        # 현재 선택한 숫자의 개수가 M과 같으면 조합을 출력
        if len(path) == M:
            print(path)
            return
        
        # 완전탐색: start 인덱스부터 nums의 끝까지 반복
        for i in range(start, len(nums)):
            # 현재 숫자 nums[i]를 선택하고, 다음 숫자를 선택하기 위해 dfs 호출
            dfs(i + 1, path + [nums[i]])

    # 초기 호출: 인덱스 0부터 시작하고, 빈 경로로 시작
    dfs(0, [])

# 예시
nums = [1, 2, 3, 4]
M = 2
combinations(nums, M)
```

위 코드는 `1, 2, 3, 4` 중에서 2개의 숫자를 고르는 모든 경우를 출력

## 3. 완전탐색 사용 시 주의사항
- **시간 복잡도**: 완전탐색은 가능한 모든 경우를 다 체크하기 때문에 보통 시간 복잡도가 매우 커짐 <br>
예를 들어, 주어진 숫자의 개수가 `n`일 때, 모든 부분 집합을 탐색하면 시간 복잡도는 `O(2^n)`이 됨<br>

- **최적화 필요성**: 문제의 크기가 커지면 완전탐색은 시간이 너무 오래 걸리기 때문에, 더 효율적인 알고리즘이 필요<br>
**동적 계획법(DP)**, **이분 탐색**, **그리디 알고리즘** 등을 고려할 것.

## 4. 완전탐색을 언제 사용할까?
- **작은 문제에 유용**: 문문제의 크기가 작고 탐색 알고리즘이 필요한 경우에 완전탐색은 쉽게 구현할 수 있음. (단, 문제 크기가 커지면 비효율적)
- **정확한 답을 구할 때**: 모든 경우를 다 체크해야 정확한 답을 구할 수 있는 문제에서 사용.
- **그리디, DP 등의 기법이 어려운 문제**에서 사용.

## 6. 결론
완전탐색은 **단순하고 직관적**인 방법으로 문제를 해결할 수 있지만, 문제의 크기가 커질수록 비효율적이 될 수 있으므로, 
문제의 크기나 조건에 따라 더 효율적인 알고리즘을 사용하는 것이 좋다.