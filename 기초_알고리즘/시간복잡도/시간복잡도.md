# 알고리즘 시간 복잡도와 점근적 표기법

## 1. 알고리즘 분석
우리는 효율적인 알고리즘을 설계해야한다.
**시간 복잡도**와 **공간 복잡도**를 측정하여 알고리즘의 성능을 개선하는 방법에 대해 알아보자.

- **시간 복잡도**: 알고리즘이 실행되는 시간 분석
- **공간 복잡도**: 알고리즘이 실행되는 동안 사용하는 메모리 양 분석

### 1.1. 시간 복잡도
- 주어진 문제에 대해 알고리즘이 수행되는 시간의 양
1.  보통 **입력 크기 n**에 대한 함수로 표현<br>
이는 알고리즘이 얼마나 **효율적으로 문제를 해결할 수 있는지를 결정**하는 지표임.

#### 예시:
- **O(1)**: 상수 시간. 입력 크기와 관계없이 일정한 시간이 소요됨
- **O(n)**: 선형 시간. 입력 크기가 증가할수록 실행 시간이 비례하여 증가함.
- **O(n²)**: 이차 시간. 중첩된 루프에서 자주 발생.
  
### 1.2. 공간 복잡도
1. 공간 복잡도는 알고리즘이 실행되는 동안 사용하는 메모리의 양을 측정함.
2.  시간 복잡도와 마찬가지로 입력 크기 n에 따라 변화하며, **임시 저장소**나 **재귀 호출의 깊이**에 영향을 받음.

---

## 2. 점근적 표기법
**알고리즘의 성능**을 **수학적**으로 표현하는 방법 <br>
 알고리즘의 실행 시간을 표현할 때, 입력 크기 n에 대해 얼마나 시간이 소요되는지를 나타내는 여러 가지 표기법 있음.

### 2.1 Ο-표기 (빅-오, 상한)
- **의미**: 알고리즘의 성능에 대해 최악의 경우를 표현하는 **상한**<br> 
즉, **최악의 경우 입력 크기가 매우 커지더라도 해당 알고리즘이 소요하는 시간은 이 값을 초과하지 않음.**
- **수학적 정의**: `f(n) ∈ O(g(n))`일 때, `f(n)`은 `g(n)`보다 더 빠르게 증가하지 않음.
- **예시**:
  - O(n), O(n²), O(n log n), O(2ⁿ)
  
#### 예시:
- **O(n)**: 배열에서 특정 요소를 찾는 작업 (순차 검색)
- **O(n²)**: 이중 루프를 사용하는 정렬 알고리즘 (예: 버블 정렬)

### 2.2 Ω-표기 (빅-오메가, 하한)
- **의미**: 알고리즘의 성능에 대해 **최선의 경우**를 표현하는 **하한** <br> 
즉, 최선의 경우라도 알고리즘이 소요하는 시간은 이 값을 넘지 않음.
- **수학적 정의**: `f(n) ∈ Ω(g(n))`일 때, `f(n)`은 `g(n)`보다 느리게 증가하지 않음.
- **예시**:
  - Ω(n), Ω(n log n)

#### 예시:
- **Ω(n)**: 배열에서 최선의 경우 (첫 번째 요소가 목표값인 경우)

### 2.3 Θ-표기 (쎄타, 상한과 하한 동일)
- **의미**: 알고리즘의 성능에 대해 **상한**과 **하한이 동일**한 경우<br> 
즉, 알고리즘이 입력 크기가 커짐에 따라 해당 시간 복잡도로 정확하게 증가한다고 표현.
- **수학적 정의**: `f(n) ∈ Θ(g(n))`일 때, `f(n)`은 `g(n)`과 같은 속도로 증가.
- **예시**: 
  - Θ(n), Θ(n²)
  
#### 예시:
- **Θ(n)**: 정렬된 배열에서 첫 번째 요소를 찾는 경우

### 2.4 o-표기 (리틀-오, 느린 증가)
- **의미**: 함수가 `g(n)`보다 더 느리게 증가한다는 것을 의미.
- **수학적 정의**: `f(n) ∈ o(g(n))`일 때, `f(n)`은 `g(n)`보다 느리게 증가합니다.
- **예시**:
  - o(n²) = {n log n, 5n, 100}

### 2.5 ω-표기 (리틀-오메가, 빠른 증가)
- **의미**: 함수가 `g(n)`보다 더 빠르게 증가한다는 것을 의미.
- **수학적 정의**: `f(n) ∈ ω(g(n))`일 때, `f(n)`은 `g(n)`보다 더 빠르게 증가.
- **예시**:
  - ω(n²) = {n³, 2ⁿ}

---

## 3. 알고리즘 예시와 시간 복잡도
### 3.1 순차 검색 (Sequential Search)ㄴ
- **최악의 경우**: O(n)
- **최선의 경우**: O(1)

#### 설명:
순차 검색은 배열의 모든 요소를 확인하는 방식.<br> 
가장 큰 입력에 대해서는 O(n)의 시간이 걸리지만, 찾고자 하는 요소가 첫 번째 위치에 있을 경우에는 O(1) 시간이 소요됨.

### 3.2 이진 검색 (Binary Search)
- **최악의 경우**: O(log n)
- **최선의 경우**: O(1)

#### 설명:
이진 검색은 정렬된 배열에서 중간 값을 기준으로 탐색 범위를 반으로 나누어가며 진행함. 이는 O(log n)으로, 탐색 범위가 반으로 줄어드는 방식.

### 3.3 버블 정렬 (Bubble Sort)
- **최악의 경우**: O(n²)
- **최선의 경우**: O(n)

#### 설명:
버블 정렬은 인접한 요소들을 비교하여 교환하는 방식.<br>
최악의 경우에는 O(n²) 시간이 소요되며, 최선의 경우에는 이미 정렬된 배열에 대해서 O(n) 시간이 걸림.
---
## 4. 점근적 분석의 중요성
알고리즘의 **점근적 분석**을 통해 알고리즘이 큰 입력에 대해 얼마나 효율적인지를 평가가능.<br> 
이를 통해 다양한 알고리즘을 비교하고, 주어진 문제에 적합한 효율적인 알고리즘을 선택가능함.

- **작은 입력**에서는 알고리즘의 효율성이 크게 중요하지 않음.
- **큰 입력**에 대해서는 효율적인 알고리즘이 필요. 비효율적인 알고리즘은 실행 시간이 급격히 증가함.
---

## 5. 알고리즘의 공간 복잡도
공간 복잡도는 알고리즘이 실행될 때 필요한 메모리 공간을 분석하는 데 사용됨. <br>
공간 복잡도는 주로 두 가지 요소에 의존.
- 1. **고정적인 메모리**: 알고리즘이 실행되기 전에 필요한 고정적인 메모리
- 2. **동적 메모리**: 알고리즘 실행 중에 생성되는 메모리

### 예시:
- **O(1)**: 상수 크기의 메모리를 사용하는 알고리즘 (예: 변수 몇 개만 사용하는 알고리즘)
- **O(n)**: 입력 크기에 비례하는 메모리를 사용하는 알고리즘 (예: 배열 크기 만큼 메모리 사용)

---
## 6. 결론
1.  **시간 복잡도**와 **공간 복잡도**를 평가하고, 다양한 **점근적 표기법**을 활용하여 효율적인 알고리즘을 선택할 수 있음.
2. **점근적 표기법**을 사용하면 알고리즘의 성능을 수학적으로 분석할 수 있음.
**입력 크기**가 커짐에 따라 알고리즘의 효율성을 평가하는 데 중요한 도구가 됨. (테스트 표본 증가)
