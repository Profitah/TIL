dp : 문제를 작은 하위 문제로 나누고, 그 결과를 **저장(메모)**해서, 중복 계산을 피하는 최적화 기법 (방법론)

1. 중복되는 부분 문제 : 같은 하위 문제가 여러 번 반복해서 등장하는 구조 / 예: 피보나치 수열 f(n) = f(n-1) + f(n-2)는 f(3)이 여러 번 계산됨
2. 최적 부분 구조  : 이미 계산한 하위 문제의 결과를 저장해 다시 계산하지 않도록 하는 기법. / 피보나치 식쓰고 그래프 그리기 : 같은 하위문제가 여러번 반복해서 등장한 것 보여주기
**문제의 정답이 하위 문제들의 정답을 조합해서 만들어질 수 있는 구조여야 한다** 예/최대 연속 부분합 (Kadane’s Algorithm)
문제: 정수 배열에서 연속된 구간의 합 중 가장 큰 값을 구하라. dp[i] = max(dp[i-1] + arr[i], arr[i])

## ✅ 작은 문제 → 큰 문제
### 📌 이 표현은 본질적으로 **Bottom-Up 방식**을 뜻합니다.
- 작은 문제부터 차례로 해결하면서 **큰 문제의 답을 만들어 나가는 방식**
- 반복문과 배열(또는 딕셔너리)을 활용
- **재귀 없이** 안정적이며 빠릅니다
---
## ✅ 바텀업 (Bottom-Up) 방식

```python
def fib(n):
    if n == 0:
        return 0
    dp = [0] * (n + 1)  # 테이블 선언
    dp[1] = 1

    for i in range(2, n + 1):
        # 작은 문제 (i-1, i-2)의 해를 이용해
        # 큰 문제 i를 계산
        dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]
```

### ✅ 흐름 예시 (fib(5))

```text
dp[0] = 0
dp[1] = 1 
dp[2] = dp[1] + dp[0] = 1
dp[3] = dp[2] + dp[1] = 2
dp[4] = dp[3] + dp[2] = 3
dp[5] = dp[4] + dp[3] = 5
```

> 즉, 작은 문제인 `fib(0)`, `fib(1)`부터 순서대로 계산하여  
> 최종적으로 `fib(5)`라는 큰 문제의 해를 구함

---

## ✅ 탑다운 (Top-Down) 방식도 "작은 문제 → 큰 문제"인가?

❌ **아니요.**  
탑다운은 일반적으로 **"큰 문제 → 작은 문제"**의 흐름입니다.

```python
def fib(n):
    if n <= 1:
        return n
    return fib(n - 1) + fib(n - 2)
```

- `fib(5)`를 구하려고 하며 → 그걸 구하기 위해 `fib(4)`와 `fib(3)` 호출  
- 그 안에서 또 `fib(3)`, `fib(2)` … 식으로 **문제를 쪼개 내려갑니다**

👉 큰 문제를 해결하려면 먼저 작은 문제를 해결해야 하므로  
**실제로는 작은 문제를 바탕으로 큰 문제의 해가 구성**됩니다.

---

## 🔍 핵심 정리

| 방식       | 계산 순서         | 실제 구조                     |
|------------|--------------------|--------------------------------|
| Top-Down   | 큰 문제 → 작은 문제 | **문제는 나누지만**, 결국 작은 문제가 먼저 계산되어야 함 |
| Bottom-Up  | 작은 문제 → 큰 문제 | 처음부터 차례로 쌓아 올라감       |

---

## 🧠 요약

- **"작은 문제 → 큰 문제"**는 보통 **Bottom-Up** 방식을 가리킴
- **Top-Down**은 큰 문제부터 시작하지만 **작은 문제를 먼저 계산**해야 하므로  
  → 두 방식 모두 **작은 문제의 해를 이용해 큰 문제를 해결한다**는 공통점이 있음