dp는 문제를 작은 하위문제로 나누고, 그 결과를 저장해서 중복 계산을 피하는 최적화 기법입니다.

이 기법은 아무때나 사용할 수 있는것은 아니고, 
사용하는데 조건이 있는데요.

첫번째, 같은 하위문제가 여러번 반복해서 등장하는 구조여야 합니다.
예를 들어 피보나치 수열에 대해 생각해보죠.

/*fib(n) = fib(n-1) + fib(n-2)
fib(3) = fib(2) + fib(1)
fib(2) = fib(1) + fib(0)

`fib(1)`이 중복호출 됩니다.*/

두번째, 이미 계산한 하위 문제의 해를 저장해 다시 계산하지 않는 구조,
즉, 문제의 정답이 하위 문제들의 정답을 조합해서 만들어질 수 있는 구조여야 합니다.
/*dp[i] = max(dp[i-1] + arr[i], arr[i]) */


dp를 표현하는 기법 (표현기법)에는 2가지가 있습니다.

첫째, Top-Down 방식 
이 방식은 **큰 문제를 먼저 호출하고**,  
해결을 위해 **필요한 작은 문제를 재귀적으로 내려가며** 해결하는 방식입니다.
메모이제이션 : 이미 계산한 결과를 저장해두고, 같은 입력이 들어오면 다시 계산하지 않고 저장된 값을 사용하는 기법.
중복계산을 방지해 코드 효율을 높인다. 이미 계산한걸 또 계산하려면 개 빡치기 때문이죠.
# Top-Down 방식: 재귀 + (딕셔너리형식으로 구현할 수 있는) 메모이제이션  사용
memo = {}

def fib(n):  # 예: fib(6)
    if n <= 1:
        return n
    if n not in memo:
        memo[n] = fib(n - 1) + fib(n - 2)  # 큰 문제를 위해 작은 문제를 호출
    return memo[n]

print(fib(6))  

"""
fib(6) 호출 시
- fib(6) → fib(5) + fib(4)
- fib(5) → fib(4) + fib(3)
- fib(4) → fib(3) + fib(2)
- fib(3) → fib(2) + fib(1)
- fib(2) → fib(1) + fib(0)
- fib(1) → 1
- fib(0) → 0
"""

둘째, Bottom-Up 방식
- 이 방식은 작은 문제를 먼저 해결하고, 뒤이어 큰 문제를 해결하는 방식입니다.
마찬가지로 피보나치식을 예로 들어보죠.
# Bottom-Up 방식: 반복문 + 테이블(배열 딕셔너리 등) 사용
def fib(n): # 6호출
    if n == 0:
        return 0
    dp = [0] * (n + 1)  
    dp[1] = 1

    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2] # 작은 문제 (i-1, i-2)의 해를 이용해 큰 문제 i를 계산

    return dp[n] # dp[6] = 8

"""
fib(6) 호출 시
# dp[0] = 0
# dp[1] = 1
# dp[2] = dp[1] + dp[0] = 1
# dp[3] = dp[2] + dp[1] = 2
# dp[4] = dp[3] + dp[2] = 3
# dp[5] = dp[4] + dp[3] = 5
# dp[6] = dp[5] + dp[4] = 8
"""


예상질문
분할정복과 dp의 차이점은?
DP에는 dp가 가능한 조건 두가지가 있는데, 
분할정복은 하위문제들이 중복되야 한다는 조건을 충족하지 않아도된다.
dp는 dp가 가능한 조건을 모두 충족해야한다.