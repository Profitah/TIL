## ✅ DP란?
> 문제를 **작은 하위 문제로 나누고**,  
> 그 결과를 **저장(메모)**해서 **중복 계산을 피하는 최적화 기법 // 정수 배열에서 연속된 구간의 합 중 가장 큰 값을 구하라.**

---

## ✅ DP가 가능한 조건

1. **중복되는 부분 문제 (Overlapping Subproblems)**  
   → 같은 하위 문제가 여러 번 반복해서 등장  
   예: `f(n) = f(n-1) + f(n-2)`에서 `f(3)`은 여러 번 호출됨

2. **최적 부분 구조 (Optimal Substructure)**  
   → 문제의 정답이 하위 문제의 정답 조합으로 구성됨  
   예: `dp[i] = max(dp[i-1] + arr[i], arr[i])` 

---

## ✅ 점화식이란?
- 반복되는 계산 규칙을 **일반화**한 공식  
- **문제에서 직접 계산해보며 관찰**해서 도출됨  
- 외워두면 **같은 유형 문제에 바로 적용 가능**

예:  
```text
fib(n) = fib(n-1) + fib(n-2)
→ dp[i] = dp[i-1] + dp[i-2]
```

---

## ✅ DP 표현 방식

| 방식      | 특징                           | 구현 방식                        |
|-----------|--------------------------------|-----------------------------------|
| Top-Down | 큰 문제 → 작은 문제             | 재귀 + 메모이제이션 (`dict`)     |
| Bottom-Up| 작은 문제 → 큰 문제             | 반복문 + 테이블 (`list`, `dp[]`) |

> 큰 문제에서 작은 문제를 해결하는 방식의 흐름을 가진 top-down
> 작은 문제에서 큰 문제를 해결하는 방식의 흐름을 가진 top-down
---

## ✅ 예제 코드: Top-Down (재귀 + 메모이제이션)
- 메모이제이션 : 이미 계산한 결과를 저장해두고, 같은 입력이 들어오면 다시 계산하지 않고 저장된 값을 사용하는 기법

```python
# 점화식: fib(n) = fib(n-1) + fib(n-2)
# 점화식은 작은 값부터 직접 계산해보고,
# 현재 값이 이전 두 항의 합이라는 규칙을 발견해서 도출됨

memo = {}

def fib(n):  # 큰 문제부터 호출 → 작은 문제로 내려감
    if n <= 1:
        return n
    if n not in memo:
        memo[n] = fib(n - 1) + fib(n - 2)
    return memo[n]

print(fib(6))  # 출력: 8
```

---

## ✅ 예제 코드: Bottom-Up (반복문 + 테이블)

```python
# 점화식: dp[i] = dp[i-1] + dp[i-2]
# 이 점화식은 다음 조건을 만족 → DP로 해결 가능

# 1. 중복되는 부분 문제: dp[i-1], dp[i-2]가 반복 사용됨
# 2. 최적 부분 구조: dp[i]는 작은 문제 dp[i-1], dp[i-2]로 구성됨

def fib(n):
    if n == 0:
        return 0
    dp = [0] * (n + 1)  # DP 테이블 초기화
    dp[1] = 1           # 초기 조건

    for i in range(2, n + 1):  # 작은 문제부터 차례로 계산
        dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]

print(fib(6))  # 출력: 8
```

---

## ✅ 어떤 방식으로 풀어야 할까?

| 상황                                | 추천 방식 | 이유                             |
|-------------------------------------|------------|----------------------------------|
| DFS랑 섞어 경로 탐색, 조건 분기 필요 | Top-Down  | 코드가 유연하고 구현이 쉬움      |
| 반복적으로 누적, 점화식이 명확할 때 | Bottom-Up | 빠르고 메모리 안정적             |
| N이 크고 시간 제한이 빡빡할 때       | Bottom-Up | 속도가 빠름, 재귀 깊이 문제 없음 |
| 테스트용 빠른 코드가 필요할 때      | Top-Down  | 직관적이며 작성이 간편함          |

---

## ✅ 마무리 요약

- DP는 **작은 문제를 풀고 결과를 저장해** 큰 문제를 푸는 방법론
- 표현 방식은 **Top-Down**(재귀) 또는 **Bottom-Up**(반복문)
- 핵심은 **점화식 관찰 → 중복 문제 확인 → 저장 구조 설계**

---

> **이게 브론즈 1이었다고? 하하하 죽고 싶다.**