# ✅ 동적 프로그래밍(DP) 설명 및 예시

DP는 문제를 **작은 하위 문제로 나누고**,  
그 결과를 **저장해서 중복 계산을 피하는 최적화 기법**입니다.

이 기법은 아무 문제에나 사용할 수는 없고, 적용 조건이 있습니다.

---

## ✅ DP 적용 조건

### 1. 중복되는 부분 문제
같은 하위 문제가 여러 번 반복해서 등장하는 구조여야 합니다.

예: 피보나치 수열
```python
fib(n) = fib(n-1) + fib(n-2)
fib(3) = fib(2) + fib(1)
fib(2) = fib(1) + fib(0)
# 'fib(1)'이 중복 호출됨
```

### 2. 최적 부분 구조
이미 계산한 하위 문제의 해를 저장해 다시 계산하지 않는 구조.  
즉, **문제의 정답이 하위 문제들의 정답을 조합해서 만들어질 수 있어야 합니다.**
```python
# 예: 최대 연속 부분합
dp[i] = max(dp[i-1] + arr[i], arr[i])
```

---

## ✅ DP 표현 기법 (Top-Down / Bottom-Up)

### 🔹 Top-Down 방식
- **큰 문제를 먼저 호출**하고,  
- **필요한 작은 문제를 재귀적으로 내려가며 해결**  
- 메모이제이션 사용 (딕셔너리 등)

```python
# Top-Down 방식: 재귀 + 메모이제이션
memo = {}

def fib(n):  # 예: fib(6)
    if n <= 1:
        return n
    if n not in memo:
        memo[n] = fib(n - 1) + fib(n - 2)
    return memo[n]

print(fib(6))  # 출력: 8
```

```text
fib(6) 호출 시
- fib(6) → fib(5) + fib(4)
- fib(5) → fib(4) + fib(3)
- fib(4) → fib(3) + fib(2)
- fib(3) → fib(2) + fib(1)
- fib(2) → fib(1) + fib(0)
- fib(1) → 1
- fib(0) → 0
```

> 메모이제이션: 이미 계산한 결과를 저장해 같은 입력이 들어오면 다시 계산하지 않고 저장된 값을 사용  
> 중복 계산을 방지하여 코드 효율을 높임 (이미 계산한 걸 또 계산하면… **개 빡침**)

---

### 🔹 Bottom-Up 방식
- **작은 문제부터 차례로 해결**하면서 큰 문제의 답을 만들어감
- **반복문 + 배열 또는 딕셔너리 테이블** 사용

```python
# Bottom-Up 방식: 반복문 + 테이블
def fib(n):  # 예: fib(6)
    if n == 0:
        return 0
    dp = [0] * (n + 1)
    dp[1] = 1

    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]  # 작은 문제(i-1, i-2)의 해를 이용해 큰 문제 i를 계산

    return dp[n]

print(fib(6))  # 출력: 8
```

```text
fib(6) 호출 시
- dp[0] = 0
- dp[1] = 1
- dp[2] = dp[1] + dp[0] = 1
- dp[3] = dp[2] + dp[1] = 2
- dp[4] = dp[3] + dp[2] = 3
- dp[5] = dp[4] + dp[3] = 5
- dp[6] = dp[5] + dp[4] = 8
```

> ✅ **재귀 없이** 안정적이며 빠르고,  
> ✅ 배열을 활용해 **순차적으로 쌓아올리는 방식**입니다.

---

## ❓ 예상 질문

### Q. 분할정복과 DP의 차이점은?
- 분할정복은 하위 문제들을 **중복 없이** 나누어 해결
- DP는 **같은 하위 문제가 반복되어야 하며**,  
  그 결과를 저장해 다시 쓰는 구조여야 함
- 즉, DP는 "중복 하위 문제 + 저장의 필요성"이라는 **조건을 만족하는** 문제에서만 사용 가능